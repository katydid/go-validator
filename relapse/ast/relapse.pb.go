// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: relapse.proto

package ast

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/katydid/validator-go/relapse/types"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Grammar is the ast node representing the whole grammar.
type Grammar struct {
	TopPattern   *Pattern       `protobuf:"bytes,1,opt,name=TopPattern" json:"TopPattern,omitempty"`
	PatternDecls []*PatternDecl `protobuf:"bytes,2,rep,name=PatternDecls" json:"PatternDecls,omitempty"`
	After        *Space         `protobuf:"bytes,3,opt,name=After" json:"After,omitempty"`
}

func (m *Grammar) Reset()      { *m = Grammar{} }
func (*Grammar) ProtoMessage() {}
func (*Grammar) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{0}
}
func (m *Grammar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Grammar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Grammar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Grammar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grammar.Merge(dst, src)
}
func (m *Grammar) XXX_Size() int {
	return m.Size()
}
func (m *Grammar) XXX_DiscardUnknown() {
	xxx_messageInfo_Grammar.DiscardUnknown(m)
}

var xxx_messageInfo_Grammar proto.InternalMessageInfo

func (m *Grammar) GetTopPattern() *Pattern {
	if m != nil {
		return m.TopPattern
	}
	return nil
}

func (m *Grammar) GetPatternDecls() []*PatternDecl {
	if m != nil {
		return m.PatternDecls
	}
	return nil
}

func (m *Grammar) GetAfter() *Space {
	if m != nil {
		return m.After
	}
	return nil
}

// PatternDecl is the ast node for the declaration of a pattern.
type PatternDecl struct {
	Hash    *Keyword `protobuf:"bytes,1,opt,name=Hash" json:"Hash,omitempty"`
	Before  *Space   `protobuf:"bytes,2,opt,name=Before" json:"Before,omitempty"`
	Name    string   `protobuf:"bytes,3,opt,name=Name" json:"Name"`
	Eq      *Keyword `protobuf:"bytes,4,opt,name=Eq" json:"Eq,omitempty"`
	Pattern *Pattern `protobuf:"bytes,5,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *PatternDecl) Reset()      { *m = PatternDecl{} }
func (*PatternDecl) ProtoMessage() {}
func (*PatternDecl) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{1}
}
func (m *PatternDecl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatternDecl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatternDecl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PatternDecl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatternDecl.Merge(dst, src)
}
func (m *PatternDecl) XXX_Size() int {
	return m.Size()
}
func (m *PatternDecl) XXX_DiscardUnknown() {
	xxx_messageInfo_PatternDecl.DiscardUnknown(m)
}

var xxx_messageInfo_PatternDecl proto.InternalMessageInfo

func (m *PatternDecl) GetHash() *Keyword {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *PatternDecl) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *PatternDecl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PatternDecl) GetEq() *Keyword {
	if m != nil {
		return m.Eq
	}
	return nil
}

func (m *PatternDecl) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

// Pattern is the ast node for the union of all possible patterns.
type Pattern struct {
	Empty      *Empty      `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
	TreeNode   *TreeNode   `protobuf:"bytes,3,opt,name=TreeNode" json:"TreeNode,omitempty"`
	LeafNode   *LeafNode   `protobuf:"bytes,4,opt,name=LeafNode" json:"LeafNode,omitempty"`
	Concat     *Concat     `protobuf:"bytes,5,opt,name=Concat" json:"Concat,omitempty"`
	Or         *Or         `protobuf:"bytes,6,opt,name=Or" json:"Or,omitempty"`
	And        *And        `protobuf:"bytes,7,opt,name=And" json:"And,omitempty"`
	ZeroOrMore *ZeroOrMore `protobuf:"bytes,8,opt,name=ZeroOrMore" json:"ZeroOrMore,omitempty"`
	Reference  *Reference  `protobuf:"bytes,9,opt,name=Reference" json:"Reference,omitempty"`
	Not        *Not        `protobuf:"bytes,10,opt,name=Not" json:"Not,omitempty"`
	ZAny       *ZAny       `protobuf:"bytes,11,opt,name=ZAny" json:"ZAny,omitempty"`
	Contains   *Contains   `protobuf:"bytes,12,opt,name=Contains" json:"Contains,omitempty"`
	Optional   *Optional   `protobuf:"bytes,13,opt,name=Optional" json:"Optional,omitempty"`
	Interleave *Interleave `protobuf:"bytes,14,opt,name=Interleave" json:"Interleave,omitempty"`
}

func (m *Pattern) Reset()      { *m = Pattern{} }
func (*Pattern) ProtoMessage() {}
func (*Pattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{2}
}
func (m *Pattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Pattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pattern.Merge(dst, src)
}
func (m *Pattern) XXX_Size() int {
	return m.Size()
}
func (m *Pattern) XXX_DiscardUnknown() {
	xxx_messageInfo_Pattern.DiscardUnknown(m)
}

var xxx_messageInfo_Pattern proto.InternalMessageInfo

func (m *Pattern) GetEmpty() *Empty {
	if m != nil {
		return m.Empty
	}
	return nil
}

func (m *Pattern) GetTreeNode() *TreeNode {
	if m != nil {
		return m.TreeNode
	}
	return nil
}

func (m *Pattern) GetLeafNode() *LeafNode {
	if m != nil {
		return m.LeafNode
	}
	return nil
}

func (m *Pattern) GetConcat() *Concat {
	if m != nil {
		return m.Concat
	}
	return nil
}

func (m *Pattern) GetOr() *Or {
	if m != nil {
		return m.Or
	}
	return nil
}

func (m *Pattern) GetAnd() *And {
	if m != nil {
		return m.And
	}
	return nil
}

func (m *Pattern) GetZeroOrMore() *ZeroOrMore {
	if m != nil {
		return m.ZeroOrMore
	}
	return nil
}

func (m *Pattern) GetReference() *Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *Pattern) GetNot() *Not {
	if m != nil {
		return m.Not
	}
	return nil
}

func (m *Pattern) GetZAny() *ZAny {
	if m != nil {
		return m.ZAny
	}
	return nil
}

func (m *Pattern) GetContains() *Contains {
	if m != nil {
		return m.Contains
	}
	return nil
}

func (m *Pattern) GetOptional() *Optional {
	if m != nil {
		return m.Optional
	}
	return nil
}

func (m *Pattern) GetInterleave() *Interleave {
	if m != nil {
		return m.Interleave
	}
	return nil
}

// Empty is the ast node for the Empty pattern.
type Empty struct {
	Empty *Keyword `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{3}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func (m *Empty) GetEmpty() *Keyword {
	if m != nil {
		return m.Empty
	}
	return nil
}

// TreeNode is the ast node for the TreeNode pattern.
type TreeNode struct {
	Name    *NameExpr `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Colon   *Keyword  `protobuf:"bytes,2,opt,name=Colon" json:"Colon,omitempty"`
	Pattern *Pattern  `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *TreeNode) Reset()      { *m = TreeNode{} }
func (*TreeNode) ProtoMessage() {}
func (*TreeNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{4}
}
func (m *TreeNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TreeNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeNode.Merge(dst, src)
}
func (m *TreeNode) XXX_Size() int {
	return m.Size()
}
func (m *TreeNode) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeNode.DiscardUnknown(m)
}

var xxx_messageInfo_TreeNode proto.InternalMessageInfo

func (m *TreeNode) GetName() *NameExpr {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *TreeNode) GetColon() *Keyword {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *TreeNode) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

// Contains is the ast node for the Contains pattern.
type Contains struct {
	Dot     *Keyword `protobuf:"bytes,1,opt,name=Dot" json:"Dot,omitempty"`
	Pattern *Pattern `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *Contains) Reset()      { *m = Contains{} }
func (*Contains) ProtoMessage() {}
func (*Contains) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{5}
}
func (m *Contains) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contains) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contains.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Contains) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contains.Merge(dst, src)
}
func (m *Contains) XXX_Size() int {
	return m.Size()
}
func (m *Contains) XXX_DiscardUnknown() {
	xxx_messageInfo_Contains.DiscardUnknown(m)
}

var xxx_messageInfo_Contains proto.InternalMessageInfo

func (m *Contains) GetDot() *Keyword {
	if m != nil {
		return m.Dot
	}
	return nil
}

func (m *Contains) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

// LeafNode is the ast node for the LeafNode pattern.
type LeafNode struct {
	Expr *Expr `protobuf:"bytes,1,opt,name=Expr" json:"Expr,omitempty"`
}

func (m *LeafNode) Reset()      { *m = LeafNode{} }
func (*LeafNode) ProtoMessage() {}
func (*LeafNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{6}
}
func (m *LeafNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeafNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LeafNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafNode.Merge(dst, src)
}
func (m *LeafNode) XXX_Size() int {
	return m.Size()
}
func (m *LeafNode) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafNode.DiscardUnknown(m)
}

var xxx_messageInfo_LeafNode proto.InternalMessageInfo

func (m *LeafNode) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

// Concat is the ast node for the Concat pattern.
type Concat struct {
	OpenBracket  *Keyword `protobuf:"bytes,2,opt,name=OpenBracket" json:"OpenBracket,omitempty"`
	LeftPattern  *Pattern `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Comma        *Keyword `protobuf:"bytes,4,opt,name=Comma" json:"Comma,omitempty"`
	RightPattern *Pattern `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraComma   *Keyword `protobuf:"bytes,6,opt,name=ExtraComma" json:"ExtraComma,omitempty"`
	CloseBracket *Keyword `protobuf:"bytes,7,opt,name=CloseBracket" json:"CloseBracket,omitempty"`
}

func (m *Concat) Reset()      { *m = Concat{} }
func (*Concat) ProtoMessage() {}
func (*Concat) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{7}
}
func (m *Concat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Concat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Concat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Concat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Concat.Merge(dst, src)
}
func (m *Concat) XXX_Size() int {
	return m.Size()
}
func (m *Concat) XXX_DiscardUnknown() {
	xxx_messageInfo_Concat.DiscardUnknown(m)
}

var xxx_messageInfo_Concat proto.InternalMessageInfo

func (m *Concat) GetOpenBracket() *Keyword {
	if m != nil {
		return m.OpenBracket
	}
	return nil
}

func (m *Concat) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Concat) GetComma() *Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Concat) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Concat) GetExtraComma() *Keyword {
	if m != nil {
		return m.ExtraComma
	}
	return nil
}

func (m *Concat) GetCloseBracket() *Keyword {
	if m != nil {
		return m.CloseBracket
	}
	return nil
}

// Or is the ast node for the Or pattern.
type Or struct {
	OpenParen    *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Pipe         *Keyword `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	RightPattern *Pattern `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Or) Reset()      { *m = Or{} }
func (*Or) ProtoMessage() {}
func (*Or) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{8}
}
func (m *Or) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Or) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Or.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Or) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Or.Merge(dst, src)
}
func (m *Or) XXX_Size() int {
	return m.Size()
}
func (m *Or) XXX_DiscardUnknown() {
	xxx_messageInfo_Or.DiscardUnknown(m)
}

var xxx_messageInfo_Or proto.InternalMessageInfo

func (m *Or) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Or) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Or) GetPipe() *Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *Or) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Or) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// And is the ast node for the And pattern.
type And struct {
	OpenParen    *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Ampersand    *Keyword `protobuf:"bytes,3,opt,name=Ampersand" json:"Ampersand,omitempty"`
	RightPattern *Pattern `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *And) Reset()      { *m = And{} }
func (*And) ProtoMessage() {}
func (*And) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{9}
}
func (m *And) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *And) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_And.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *And) XXX_Merge(src proto.Message) {
	xxx_messageInfo_And.Merge(dst, src)
}
func (m *And) XXX_Size() int {
	return m.Size()
}
func (m *And) XXX_DiscardUnknown() {
	xxx_messageInfo_And.DiscardUnknown(m)
}

var xxx_messageInfo_And proto.InternalMessageInfo

func (m *And) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *And) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *And) GetAmpersand() *Keyword {
	if m != nil {
		return m.Ampersand
	}
	return nil
}

func (m *And) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *And) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// ZeroOrMore is the ast node for the ZeroOrMore pattern.
type ZeroOrMore struct {
	OpenParen  *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern    *Pattern `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen *Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	Star       *Keyword `protobuf:"bytes,4,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZeroOrMore) Reset()      { *m = ZeroOrMore{} }
func (*ZeroOrMore) ProtoMessage() {}
func (*ZeroOrMore) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{10}
}
func (m *ZeroOrMore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroOrMore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroOrMore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ZeroOrMore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroOrMore.Merge(dst, src)
}
func (m *ZeroOrMore) XXX_Size() int {
	return m.Size()
}
func (m *ZeroOrMore) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroOrMore.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroOrMore proto.InternalMessageInfo

func (m *ZeroOrMore) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *ZeroOrMore) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *ZeroOrMore) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *ZeroOrMore) GetStar() *Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

// Reference is the ast node for the Reference pattern.
type Reference struct {
	At   *Keyword `protobuf:"bytes,1,opt,name=At" json:"At,omitempty"`
	Name string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
}

func (m *Reference) Reset()      { *m = Reference{} }
func (*Reference) ProtoMessage() {}
func (*Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{11}
}
func (m *Reference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reference.Merge(dst, src)
}
func (m *Reference) XXX_Size() int {
	return m.Size()
}
func (m *Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_Reference proto.InternalMessageInfo

func (m *Reference) GetAt() *Keyword {
	if m != nil {
		return m.At
	}
	return nil
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Not is the ast node for the Not pattern.
type Not struct {
	Exclamation *Keyword `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *Keyword `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern     *Pattern `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen  *Keyword `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Not) Reset()      { *m = Not{} }
func (*Not) ProtoMessage() {}
func (*Not) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{12}
}
func (m *Not) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Not) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Not.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Not) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Not.Merge(dst, src)
}
func (m *Not) XXX_Size() int {
	return m.Size()
}
func (m *Not) XXX_DiscardUnknown() {
	xxx_messageInfo_Not.DiscardUnknown(m)
}

var xxx_messageInfo_Not proto.InternalMessageInfo

func (m *Not) GetExclamation() *Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *Not) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Not) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Not) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// ZAny is the ast node for the ZAny pattern.
type ZAny struct {
	Star *Keyword `protobuf:"bytes,1,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZAny) Reset()      { *m = ZAny{} }
func (*ZAny) ProtoMessage() {}
func (*ZAny) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{13}
}
func (m *ZAny) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZAny) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZAny.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ZAny) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZAny.Merge(dst, src)
}
func (m *ZAny) XXX_Size() int {
	return m.Size()
}
func (m *ZAny) XXX_DiscardUnknown() {
	xxx_messageInfo_ZAny.DiscardUnknown(m)
}

var xxx_messageInfo_ZAny proto.InternalMessageInfo

func (m *ZAny) GetStar() *Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

// Optional is the ast node for the Optional pattern.
type Optional struct {
	OpenParen    *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern      *Pattern `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen   *Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	QuestionMark *Keyword `protobuf:"bytes,4,opt,name=QuestionMark" json:"QuestionMark,omitempty"`
}

func (m *Optional) Reset()      { *m = Optional{} }
func (*Optional) ProtoMessage() {}
func (*Optional) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{14}
}
func (m *Optional) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Optional) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Optional.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Optional) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Optional.Merge(dst, src)
}
func (m *Optional) XXX_Size() int {
	return m.Size()
}
func (m *Optional) XXX_DiscardUnknown() {
	xxx_messageInfo_Optional.DiscardUnknown(m)
}

var xxx_messageInfo_Optional proto.InternalMessageInfo

func (m *Optional) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Optional) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Optional) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *Optional) GetQuestionMark() *Keyword {
	if m != nil {
		return m.QuestionMark
	}
	return nil
}

// Interleave is the ast node for the Interleave pattern.
type Interleave struct {
	OpenCurly      *Keyword `protobuf:"bytes,2,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	LeftPattern    *Pattern `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	SemiColon      *Keyword `protobuf:"bytes,4,opt,name=SemiColon" json:"SemiColon,omitempty"`
	RightPattern   *Pattern `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraSemiColon *Keyword `protobuf:"bytes,6,opt,name=ExtraSemiColon" json:"ExtraSemiColon,omitempty"`
	CloseCurly     *Keyword `protobuf:"bytes,7,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
}

func (m *Interleave) Reset()      { *m = Interleave{} }
func (*Interleave) ProtoMessage() {}
func (*Interleave) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{15}
}
func (m *Interleave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interleave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interleave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Interleave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interleave.Merge(dst, src)
}
func (m *Interleave) XXX_Size() int {
	return m.Size()
}
func (m *Interleave) XXX_DiscardUnknown() {
	xxx_messageInfo_Interleave.DiscardUnknown(m)
}

var xxx_messageInfo_Interleave proto.InternalMessageInfo

func (m *Interleave) GetOpenCurly() *Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *Interleave) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Interleave) GetSemiColon() *Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

func (m *Interleave) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Interleave) GetExtraSemiColon() *Keyword {
	if m != nil {
		return m.ExtraSemiColon
	}
	return nil
}

func (m *Interleave) GetCloseCurly() *Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

// Expr is a union of all possible expression types, terminal, list, function and builtin function.
type Expr struct {
	RightArrow *Keyword  `protobuf:"bytes,1,opt,name=RightArrow" json:"RightArrow,omitempty"`
	Comma      *Keyword  `protobuf:"bytes,2,opt,name=Comma" json:"Comma,omitempty"`
	Terminal   *Terminal `protobuf:"bytes,3,opt,name=Terminal" json:"Terminal,omitempty"`
	List       *List     `protobuf:"bytes,4,opt,name=List" json:"List,omitempty"`
	Function   *Function `protobuf:"bytes,5,opt,name=Function" json:"Function,omitempty"`
	BuiltIn    *BuiltIn  `protobuf:"bytes,6,opt,name=BuiltIn" json:"BuiltIn,omitempty"`
}

func (m *Expr) Reset()      { *m = Expr{} }
func (*Expr) ProtoMessage() {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{16}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(dst, src)
}
func (m *Expr) XXX_Size() int {
	return m.Size()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

func (m *Expr) GetRightArrow() *Keyword {
	if m != nil {
		return m.RightArrow
	}
	return nil
}

func (m *Expr) GetComma() *Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Expr) GetTerminal() *Terminal {
	if m != nil {
		return m.Terminal
	}
	return nil
}

func (m *Expr) GetList() *List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *Expr) GetFunction() *Function {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *Expr) GetBuiltIn() *BuiltIn {
	if m != nil {
		return m.BuiltIn
	}
	return nil
}

// List is an expression that represents a typed list of expressions.
type List struct {
	Before     *Space     `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Type       types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
	OpenCurly  *Keyword   `protobuf:"bytes,3,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	Elems      []*Expr    `protobuf:"bytes,4,rep,name=Elems" json:"Elems,omitempty"`
	CloseCurly *Keyword   `protobuf:"bytes,5,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
}

func (m *List) Reset()      { *m = List{} }
func (*List) ProtoMessage() {}
func (*List) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{17}
}
func (m *List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_List.Merge(dst, src)
}
func (m *List) XXX_Size() int {
	return m.Size()
}
func (m *List) XXX_DiscardUnknown() {
	xxx_messageInfo_List.DiscardUnknown(m)
}

var xxx_messageInfo_List proto.InternalMessageInfo

func (m *List) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *List) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

func (m *List) GetOpenCurly() *Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *List) GetElems() []*Expr {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *List) GetCloseCurly() *Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

// Function is an expression that represents a function expression, which contains a function name and a list parameters.
type Function struct {
	Before     *Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Name       string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	OpenParen  *Keyword `protobuf:"bytes,3,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Params     []*Expr  `protobuf:"bytes,4,rep,name=Params" json:"Params,omitempty"`
	CloseParen *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Function) Reset()      { *m = Function{} }
func (*Function) ProtoMessage() {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{18}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(dst, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Function) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Function) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// BuiltIn is an expression that represents a builtin function.  This is represented by a symbol and an expression.
type BuiltIn struct {
	Symbol *Keyword `protobuf:"bytes,1,opt,name=Symbol" json:"Symbol,omitempty"`
	Expr   *Expr    `protobuf:"bytes,2,opt,name=Expr" json:"Expr,omitempty"`
}

func (m *BuiltIn) Reset()      { *m = BuiltIn{} }
func (*BuiltIn) ProtoMessage() {}
func (*BuiltIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{19}
}
func (m *BuiltIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuiltIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuiltIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BuiltIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuiltIn.Merge(dst, src)
}
func (m *BuiltIn) XXX_Size() int {
	return m.Size()
}
func (m *BuiltIn) XXX_DiscardUnknown() {
	xxx_messageInfo_BuiltIn.DiscardUnknown(m)
}

var xxx_messageInfo_BuiltIn proto.InternalMessageInfo

func (m *BuiltIn) GetSymbol() *Keyword {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func (m *BuiltIn) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

// Terminal is an expression that represents a literal value or variable.
type Terminal struct {
	Before      *Space    `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Literal     string    `protobuf:"bytes,2,opt,name=Literal" json:"Literal"`
	DoubleValue *float64  `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue    *int64    `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue   *uint64   `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue   *bool     `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue *string   `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue  []byte    `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
	Variable    *Variable `protobuf:"bytes,50,opt,name=Variable" json:"Variable,omitempty"`
}

func (m *Terminal) Reset()      { *m = Terminal{} }
func (*Terminal) ProtoMessage() {}
func (*Terminal) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{20}
}
func (m *Terminal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Terminal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Terminal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Terminal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Terminal.Merge(dst, src)
}
func (m *Terminal) XXX_Size() int {
	return m.Size()
}
func (m *Terminal) XXX_DiscardUnknown() {
	xxx_messageInfo_Terminal.DiscardUnknown(m)
}

var xxx_messageInfo_Terminal proto.InternalMessageInfo

func (m *Terminal) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Terminal) GetLiteral() string {
	if m != nil {
		return m.Literal
	}
	return ""
}

func (m *Terminal) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Terminal) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Terminal) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Terminal) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Terminal) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Terminal) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

func (m *Terminal) GetVariable() *Variable {
	if m != nil {
		return m.Variable
	}
	return nil
}

// Variable is a terminal.
type Variable struct {
	Type types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
}

func (m *Variable) Reset()      { *m = Variable{} }
func (*Variable) ProtoMessage() {}
func (*Variable) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{21}
}
func (m *Variable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Variable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Variable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Variable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Variable.Merge(dst, src)
}
func (m *Variable) XXX_Size() int {
	return m.Size()
}
func (m *Variable) XXX_DiscardUnknown() {
	xxx_messageInfo_Variable.DiscardUnknown(m)
}

var xxx_messageInfo_Variable proto.InternalMessageInfo

func (m *Variable) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

// Keyword represents any possible keyword.
type Keyword struct {
	Before *Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value" json:"Value"`
}

func (m *Keyword) Reset()      { *m = Keyword{} }
func (*Keyword) ProtoMessage() {}
func (*Keyword) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{22}
}
func (m *Keyword) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Keyword) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Keyword.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Keyword) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Keyword.Merge(dst, src)
}
func (m *Keyword) XXX_Size() int {
	return m.Size()
}
func (m *Keyword) XXX_DiscardUnknown() {
	xxx_messageInfo_Keyword.DiscardUnknown(m)
}

var xxx_messageInfo_Keyword proto.InternalMessageInfo

func (m *Keyword) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Keyword) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Space represents a comment or white space.
type Space struct {
	Space []string `protobuf:"bytes,1,rep,name=Space" json:"Space,omitempty"`
}

func (m *Space) Reset()      { *m = Space{} }
func (*Space) ProtoMessage() {}
func (*Space) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{23}
}
func (m *Space) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Space) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Space.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Space) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Space.Merge(dst, src)
}
func (m *Space) XXX_Size() int {
	return m.Size()
}
func (m *Space) XXX_DiscardUnknown() {
	xxx_messageInfo_Space.DiscardUnknown(m)
}

var xxx_messageInfo_Space proto.InternalMessageInfo

func (m *Space) GetSpace() []string {
	if m != nil {
		return m.Space
	}
	return nil
}

// NameExpr is a special type of expression for field names that contains a union of all the possible name expressions.
type NameExpr struct {
	Name          *Name          `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	AnyName       *AnyName       `protobuf:"bytes,2,opt,name=AnyName" json:"AnyName,omitempty"`
	AnyNameExcept *AnyNameExcept `protobuf:"bytes,3,opt,name=AnyNameExcept" json:"AnyNameExcept,omitempty"`
	NameChoice    *NameChoice    `protobuf:"bytes,4,opt,name=NameChoice" json:"NameChoice,omitempty"`
}

func (m *NameExpr) Reset()      { *m = NameExpr{} }
func (*NameExpr) ProtoMessage() {}
func (*NameExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{24}
}
func (m *NameExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NameExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NameExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NameExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameExpr.Merge(dst, src)
}
func (m *NameExpr) XXX_Size() int {
	return m.Size()
}
func (m *NameExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_NameExpr.DiscardUnknown(m)
}

var xxx_messageInfo_NameExpr proto.InternalMessageInfo

func (m *NameExpr) GetName() *Name {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NameExpr) GetAnyName() *AnyName {
	if m != nil {
		return m.AnyName
	}
	return nil
}

func (m *NameExpr) GetAnyNameExcept() *AnyNameExcept {
	if m != nil {
		return m.AnyNameExcept
	}
	return nil
}

func (m *NameExpr) GetNameChoice() *NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

// Name is a name expression and represents a union of all possible name type values.
type Name struct {
	Before      *Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	DoubleValue *float64 `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue    *int64   `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue   *uint64  `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue   *bool    `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue *string  `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue  []byte   `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
}

func (m *Name) Reset()      { *m = Name{} }
func (*Name) ProtoMessage() {}
func (*Name) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{25}
}
func (m *Name) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Name) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Name.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Name) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Name.Merge(dst, src)
}
func (m *Name) XXX_Size() int {
	return m.Size()
}
func (m *Name) XXX_DiscardUnknown() {
	xxx_messageInfo_Name.DiscardUnknown(m)
}

var xxx_messageInfo_Name proto.InternalMessageInfo

func (m *Name) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Name) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Name) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Name) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Name) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Name) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Name) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

// AnyName is a name expression that represents any name.
type AnyName struct {
	Underscore *Keyword `protobuf:"bytes,1,opt,name=Underscore" json:"Underscore,omitempty"`
}

func (m *AnyName) Reset()      { *m = AnyName{} }
func (*AnyName) ProtoMessage() {}
func (*AnyName) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{26}
}
func (m *AnyName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnyName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnyName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnyName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnyName.Merge(dst, src)
}
func (m *AnyName) XXX_Size() int {
	return m.Size()
}
func (m *AnyName) XXX_DiscardUnknown() {
	xxx_messageInfo_AnyName.DiscardUnknown(m)
}

var xxx_messageInfo_AnyName proto.InternalMessageInfo

func (m *AnyName) GetUnderscore() *Keyword {
	if m != nil {
		return m.Underscore
	}
	return nil
}

// AnyNameExpr is a name expression that represents any name except the specified name expression.
type AnyNameExcept struct {
	Exclamation *Keyword  `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *Keyword  `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Except      *NameExpr `protobuf:"bytes,3,opt,name=Except" json:"Except,omitempty"`
	CloseParen  *Keyword  `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *AnyNameExcept) Reset()      { *m = AnyNameExcept{} }
func (*AnyNameExcept) ProtoMessage() {}
func (*AnyNameExcept) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{27}
}
func (m *AnyNameExcept) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnyNameExcept) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnyNameExcept.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnyNameExcept) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnyNameExcept.Merge(dst, src)
}
func (m *AnyNameExcept) XXX_Size() int {
	return m.Size()
}
func (m *AnyNameExcept) XXX_DiscardUnknown() {
	xxx_messageInfo_AnyNameExcept.DiscardUnknown(m)
}

var xxx_messageInfo_AnyNameExcept proto.InternalMessageInfo

func (m *AnyNameExcept) GetExclamation() *Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *AnyNameExcept) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *AnyNameExcept) GetExcept() *NameExpr {
	if m != nil {
		return m.Except
	}
	return nil
}

func (m *AnyNameExcept) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// NameChoice is a name expression that represents a choice between two possible name expressions.
type NameChoice struct {
	OpenParen  *Keyword  `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Left       *NameExpr `protobuf:"bytes,2,opt,name=Left" json:"Left,omitempty"`
	Pipe       *Keyword  `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	Right      *NameExpr `protobuf:"bytes,4,opt,name=Right" json:"Right,omitempty"`
	CloseParen *Keyword  `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *NameChoice) Reset()      { *m = NameChoice{} }
func (*NameChoice) ProtoMessage() {}
func (*NameChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_relapse_9e0d729cf4b37f53, []int{28}
}
func (m *NameChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NameChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NameChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NameChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameChoice.Merge(dst, src)
}
func (m *NameChoice) XXX_Size() int {
	return m.Size()
}
func (m *NameChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_NameChoice.DiscardUnknown(m)
}

var xxx_messageInfo_NameChoice proto.InternalMessageInfo

func (m *NameChoice) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *NameChoice) GetLeft() *NameExpr {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *NameChoice) GetPipe() *Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *NameChoice) GetRight() *NameExpr {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *NameChoice) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func init() {
	proto.RegisterType((*Grammar)(nil), "ast.Grammar")
	proto.RegisterType((*PatternDecl)(nil), "ast.PatternDecl")
	proto.RegisterType((*Pattern)(nil), "ast.Pattern")
	proto.RegisterType((*Empty)(nil), "ast.Empty")
	proto.RegisterType((*TreeNode)(nil), "ast.TreeNode")
	proto.RegisterType((*Contains)(nil), "ast.Contains")
	proto.RegisterType((*LeafNode)(nil), "ast.LeafNode")
	proto.RegisterType((*Concat)(nil), "ast.Concat")
	proto.RegisterType((*Or)(nil), "ast.Or")
	proto.RegisterType((*And)(nil), "ast.And")
	proto.RegisterType((*ZeroOrMore)(nil), "ast.ZeroOrMore")
	proto.RegisterType((*Reference)(nil), "ast.Reference")
	proto.RegisterType((*Not)(nil), "ast.Not")
	proto.RegisterType((*ZAny)(nil), "ast.ZAny")
	proto.RegisterType((*Optional)(nil), "ast.Optional")
	proto.RegisterType((*Interleave)(nil), "ast.Interleave")
	proto.RegisterType((*Expr)(nil), "ast.Expr")
	proto.RegisterType((*List)(nil), "ast.List")
	proto.RegisterType((*Function)(nil), "ast.Function")
	proto.RegisterType((*BuiltIn)(nil), "ast.BuiltIn")
	proto.RegisterType((*Terminal)(nil), "ast.Terminal")
	proto.RegisterType((*Variable)(nil), "ast.Variable")
	proto.RegisterType((*Keyword)(nil), "ast.Keyword")
	proto.RegisterType((*Space)(nil), "ast.Space")
	proto.RegisterType((*NameExpr)(nil), "ast.NameExpr")
	proto.RegisterType((*Name)(nil), "ast.Name")
	proto.RegisterType((*AnyName)(nil), "ast.AnyName")
	proto.RegisterType((*AnyNameExcept)(nil), "ast.AnyNameExcept")
	proto.RegisterType((*NameChoice)(nil), "ast.NameChoice")
}
func (m *Grammar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grammar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopPattern != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.TopPattern.Size()))
		n1, err := m.TopPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.PatternDecls) > 0 {
		for _, msg := range m.PatternDecls {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRelapse(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.After != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.After.Size()))
		n2, err := m.After.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PatternDecl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatternDecl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Hash.Size()))
		n3, err := m.Hash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Before != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n4, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Eq != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Eq.Size()))
		n5, err := m.Eq.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Pattern != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n6, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Pattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pattern) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Empty.Size()))
		n7, err := m.Empty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.TreeNode != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.TreeNode.Size()))
		n8, err := m.TreeNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.LeafNode != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeafNode.Size()))
		n9, err := m.LeafNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Concat != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Concat.Size()))
		n10, err := m.Concat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Or != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Or.Size()))
		n11, err := m.Or.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.And != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.And.Size()))
		n12, err := m.And.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ZeroOrMore != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ZeroOrMore.Size()))
		n13, err := m.ZeroOrMore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Reference != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Reference.Size()))
		n14, err := m.Reference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Not != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Not.Size()))
		n15, err := m.Not.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ZAny != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ZAny.Size()))
		n16, err := m.ZAny.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Contains != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Contains.Size()))
		n17, err := m.Contains.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Optional != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Optional.Size()))
		n18, err := m.Optional.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Interleave != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Interleave.Size()))
		n19, err := m.Interleave.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Empty.Size()))
		n20, err := m.Empty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *TreeNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Name.Size()))
		n21, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Colon != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Colon.Size()))
		n22, err := m.Colon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Pattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n23, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *Contains) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contains) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Dot.Size()))
		n24, err := m.Dot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n25, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *LeafNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Expr.Size()))
		n26, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Concat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Concat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenBracket != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenBracket.Size()))
		n27, err := m.OpenBracket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n28, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Comma != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Comma.Size()))
		n29, err := m.Comma.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n30, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.ExtraComma != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ExtraComma.Size()))
		n31, err := m.ExtraComma.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.CloseBracket != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseBracket.Size()))
		n32, err := m.CloseBracket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *Or) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Or) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n33, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n34, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Pipe != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pipe.Size()))
		n35, err := m.Pipe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n36, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n37, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *And) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *And) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n38, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n39, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Ampersand != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Ampersand.Size()))
		n40, err := m.Ampersand.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n41, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n42, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *ZeroOrMore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroOrMore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n43, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n44, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n45, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Star != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Star.Size()))
		n46, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}

func (m *Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.At != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.At.Size()))
		n47, err := m.At.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *Not) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Not) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exclamation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Exclamation.Size()))
		n48, err := m.Exclamation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.OpenParen != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n49, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Pattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n50, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n51, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *ZAny) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZAny) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Star.Size()))
		n52, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}

func (m *Optional) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Optional) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n53, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n54, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n55, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.QuestionMark != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.QuestionMark.Size()))
		n56, err := m.QuestionMark.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}

func (m *Interleave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interleave) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenCurly != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenCurly.Size()))
		n57, err := m.OpenCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n58, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.SemiColon != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.SemiColon.Size()))
		n59, err := m.SemiColon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n60, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.ExtraSemiColon != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ExtraSemiColon.Size()))
		n61, err := m.ExtraSemiColon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.CloseCurly != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseCurly.Size()))
		n62, err := m.CloseCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RightArrow != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightArrow.Size()))
		n63, err := m.RightArrow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Comma != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Comma.Size()))
		n64, err := m.Comma.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Terminal != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Terminal.Size()))
		n65, err := m.Terminal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.List != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.List.Size()))
		n66, err := m.List.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Function != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Function.Size()))
		n67, err := m.Function.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.BuiltIn != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.BuiltIn.Size()))
		n68, err := m.BuiltIn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n69, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(m.Type))
	if m.OpenCurly != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenCurly.Size()))
		n70, err := m.OpenCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if len(m.Elems) > 0 {
		for _, msg := range m.Elems {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRelapse(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloseCurly != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseCurly.Size()))
		n71, err := m.CloseCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n72, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.OpenParen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n73, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRelapse(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n74, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}

func (m *BuiltIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuiltIn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Symbol != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Symbol.Size()))
		n75, err := m.Symbol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.Expr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Expr.Size()))
		n76, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *Terminal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Terminal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n77, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Literal)))
	i += copy(dAtA[i:], m.Literal)
	if m.DoubleValue != nil {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i += 8
	}
	if m.IntValue != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		dAtA[i] = 0x40
		i++
		if *m.BoolValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StringValue != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(*m.StringValue)))
		i += copy(dAtA[i:], *m.StringValue)
	}
	if m.BytesValue != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(m.BytesValue)))
		i += copy(dAtA[i:], m.BytesValue)
	}
	if m.Variable != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Variable.Size()))
		n78, err := m.Variable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *Variable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Variable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x10
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *Keyword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyword) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n79, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *Space) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Space) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Space) > 0 {
		for _, s := range m.Space {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NameExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Name.Size()))
		n80, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.AnyName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.AnyName.Size()))
		n81, err := m.AnyName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.AnyNameExcept != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.AnyNameExcept.Size()))
		n82, err := m.AnyNameExcept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.NameChoice != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.NameChoice.Size()))
		n83, err := m.NameChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *Name) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Name) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n84, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.DoubleValue != nil {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i += 8
	}
	if m.IntValue != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		dAtA[i] = 0x40
		i++
		if *m.BoolValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StringValue != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(*m.StringValue)))
		i += copy(dAtA[i:], *m.StringValue)
	}
	if m.BytesValue != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(m.BytesValue)))
		i += copy(dAtA[i:], m.BytesValue)
	}
	return i, nil
}

func (m *AnyName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Underscore != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Underscore.Size()))
		n85, err := m.Underscore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}

func (m *AnyNameExcept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyNameExcept) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exclamation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Exclamation.Size()))
		n86, err := m.Exclamation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.OpenParen != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n87, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.Except != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Except.Size()))
		n88, err := m.Except.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n89, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	return i, nil
}

func (m *NameChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameChoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n90, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.Left != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Left.Size()))
		n91, err := m.Left.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.Pipe != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pipe.Size()))
		n92, err := m.Pipe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.Right != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Right.Size()))
		n93, err := m.Right.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n94, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}

func encodeVarintRelapse(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Grammar) Size() (n int) {
	var l int
	_ = l
	if m.TopPattern != nil {
		l = m.TopPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.PatternDecls) > 0 {
		for _, e := range m.PatternDecls {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *PatternDecl) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = m.Hash.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	if m.Eq != nil {
		l = m.Eq.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Pattern) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.TreeNode != nil {
		l = m.TreeNode.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeafNode != nil {
		l = m.LeafNode.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Concat != nil {
		l = m.Concat.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ZeroOrMore != nil {
		l = m.ZeroOrMore.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Reference != nil {
		l = m.Reference.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Not != nil {
		l = m.Not.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ZAny != nil {
		l = m.ZAny.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Contains != nil {
		l = m.Contains.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Optional != nil {
		l = m.Optional.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Interleave != nil {
		l = m.Interleave.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *TreeNode) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Colon != nil {
		l = m.Colon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Contains) Size() (n int) {
	var l int
	_ = l
	if m.Dot != nil {
		l = m.Dot.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *LeafNode) Size() (n int) {
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Concat) Size() (n int) {
	var l int
	_ = l
	if m.OpenBracket != nil {
		l = m.OpenBracket.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Comma != nil {
		l = m.Comma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ExtraComma != nil {
		l = m.ExtraComma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseBracket != nil {
		l = m.CloseBracket.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Or) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pipe != nil {
		l = m.Pipe.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *And) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Ampersand != nil {
		l = m.Ampersand.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *ZeroOrMore) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Reference) Size() (n int) {
	var l int
	_ = l
	if m.At != nil {
		l = m.At.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	return n
}

func (m *Not) Size() (n int) {
	var l int
	_ = l
	if m.Exclamation != nil {
		l = m.Exclamation.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *ZAny) Size() (n int) {
	var l int
	_ = l
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Optional) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.QuestionMark != nil {
		l = m.QuestionMark.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Interleave) Size() (n int) {
	var l int
	_ = l
	if m.OpenCurly != nil {
		l = m.OpenCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.SemiColon != nil {
		l = m.SemiColon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ExtraSemiColon != nil {
		l = m.ExtraSemiColon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseCurly != nil {
		l = m.CloseCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Expr) Size() (n int) {
	var l int
	_ = l
	if m.RightArrow != nil {
		l = m.RightArrow.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Comma != nil {
		l = m.Comma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Terminal != nil {
		l = m.Terminal.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.List != nil {
		l = m.List.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BuiltIn != nil {
		l = m.BuiltIn.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *List) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	n += 1 + sovRelapse(uint64(m.Type))
	if m.OpenCurly != nil {
		l = m.OpenCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.Elems) > 0 {
		for _, e := range m.Elems {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.CloseCurly != nil {
		l = m.CloseCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Function) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *BuiltIn) Size() (n int) {
	var l int
	_ = l
	if m.Symbol != nil {
		l = m.Symbol.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Terminal) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Literal)
	n += 1 + l + sovRelapse(uint64(l))
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntValue != nil {
		n += 1 + sovRelapse(uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		n += 1 + sovRelapse(uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		n += 2
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Variable != nil {
		l = m.Variable.Size()
		n += 2 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Variable) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovRelapse(uint64(m.Type))
	return n
}

func (m *Keyword) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Value)
	n += 1 + l + sovRelapse(uint64(l))
	return n
}

func (m *Space) Size() (n int) {
	var l int
	_ = l
	if len(m.Space) > 0 {
		for _, s := range m.Space {
			l = len(s)
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	return n
}

func (m *NameExpr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.AnyName != nil {
		l = m.AnyName.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.AnyNameExcept != nil {
		l = m.AnyNameExcept.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.NameChoice != nil {
		l = m.NameChoice.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Name) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntValue != nil {
		n += 1 + sovRelapse(uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		n += 1 + sovRelapse(uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		n += 2
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *AnyName) Size() (n int) {
	var l int
	_ = l
	if m.Underscore != nil {
		l = m.Underscore.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *AnyNameExcept) Size() (n int) {
	var l int
	_ = l
	if m.Exclamation != nil {
		l = m.Exclamation.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Except != nil {
		l = m.Except.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *NameChoice) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pipe != nil {
		l = m.Pipe.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func sovRelapse(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRelapse(x uint64) (n int) {
	return sovRelapse(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Pattern) GetValue() interface{} {
	if this.Empty != nil {
		return this.Empty
	}
	if this.TreeNode != nil {
		return this.TreeNode
	}
	if this.LeafNode != nil {
		return this.LeafNode
	}
	if this.Concat != nil {
		return this.Concat
	}
	if this.Or != nil {
		return this.Or
	}
	if this.And != nil {
		return this.And
	}
	if this.ZeroOrMore != nil {
		return this.ZeroOrMore
	}
	if this.Reference != nil {
		return this.Reference
	}
	if this.Not != nil {
		return this.Not
	}
	if this.ZAny != nil {
		return this.ZAny
	}
	if this.Contains != nil {
		return this.Contains
	}
	if this.Optional != nil {
		return this.Optional
	}
	if this.Interleave != nil {
		return this.Interleave
	}
	return nil
}

func (this *Pattern) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Empty:
		this.Empty = vt
	case *TreeNode:
		this.TreeNode = vt
	case *LeafNode:
		this.LeafNode = vt
	case *Concat:
		this.Concat = vt
	case *Or:
		this.Or = vt
	case *And:
		this.And = vt
	case *ZeroOrMore:
		this.ZeroOrMore = vt
	case *Reference:
		this.Reference = vt
	case *Not:
		this.Not = vt
	case *ZAny:
		this.ZAny = vt
	case *Contains:
		this.Contains = vt
	case *Optional:
		this.Optional = vt
	case *Interleave:
		this.Interleave = vt
	default:
		return false
	}
	return true
}
func (this *NameExpr) GetValue() interface{} {
	if this.Name != nil {
		return this.Name
	}
	if this.AnyName != nil {
		return this.AnyName
	}
	if this.AnyNameExcept != nil {
		return this.AnyNameExcept
	}
	if this.NameChoice != nil {
		return this.NameChoice
	}
	return nil
}

func (this *NameExpr) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Name:
		this.Name = vt
	case *AnyName:
		this.AnyName = vt
	case *AnyNameExcept:
		this.AnyNameExcept = vt
	case *NameChoice:
		this.NameChoice = vt
	default:
		return false
	}
	return true
}
func (m *Grammar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grammar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grammar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopPattern == nil {
				m.TopPattern = &Pattern{}
			}
			if err := m.TopPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternDecls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternDecls = append(m.PatternDecls, &PatternDecl{})
			if err := m.PatternDecls[len(m.PatternDecls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &Space{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatternDecl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatternDecl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatternDecl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hash == nil {
				m.Hash = &Keyword{}
			}
			if err := m.Hash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eq == nil {
				m.Eq = &Keyword{}
			}
			if err := m.Eq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empty == nil {
				m.Empty = &Empty{}
			}
			if err := m.Empty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeNode == nil {
				m.TreeNode = &TreeNode{}
			}
			if err := m.TreeNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeafNode == nil {
				m.LeafNode = &LeafNode{}
			}
			if err := m.LeafNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Concat == nil {
				m.Concat = &Concat{}
			}
			if err := m.Concat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Or == nil {
				m.Or = &Or{}
			}
			if err := m.Or.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.And == nil {
				m.And = &And{}
			}
			if err := m.And.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroOrMore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZeroOrMore == nil {
				m.ZeroOrMore = &ZeroOrMore{}
			}
			if err := m.ZeroOrMore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reference == nil {
				m.Reference = &Reference{}
			}
			if err := m.Reference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Not", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Not == nil {
				m.Not = &Not{}
			}
			if err := m.Not.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZAny == nil {
				m.ZAny = &ZAny{}
			}
			if err := m.ZAny.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contains == nil {
				m.Contains = &Contains{}
			}
			if err := m.Contains.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Optional == nil {
				m.Optional = &Optional{}
			}
			if err := m.Optional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interleave", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interleave == nil {
				m.Interleave = &Interleave{}
			}
			if err := m.Interleave.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empty == nil {
				m.Empty = &Keyword{}
			}
			if err := m.Empty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &NameExpr{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Colon == nil {
				m.Colon = &Keyword{}
			}
			if err := m.Colon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contains) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contains: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contains: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dot == nil {
				m.Dot = &Keyword{}
			}
			if err := m.Dot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Concat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Concat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Concat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenBracket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenBracket == nil {
				m.OpenBracket = &Keyword{}
			}
			if err := m.OpenBracket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comma == nil {
				m.Comma = &Keyword{}
			}
			if err := m.Comma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraComma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraComma == nil {
				m.ExtraComma = &Keyword{}
			}
			if err := m.ExtraComma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseBracket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseBracket == nil {
				m.CloseBracket = &Keyword{}
			}
			if err := m.CloseBracket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Or) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Or: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Or: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipe == nil {
				m.Pipe = &Keyword{}
			}
			if err := m.Pipe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *And) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: And: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: And: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ampersand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ampersand == nil {
				m.Ampersand = &Keyword{}
			}
			if err := m.Ampersand.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroOrMore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroOrMore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroOrMore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &Keyword{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field At", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.At == nil {
				m.At = &Keyword{}
			}
			if err := m.At.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Not) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Not: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Not: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclamation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exclamation == nil {
				m.Exclamation = &Keyword{}
			}
			if err := m.Exclamation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZAny) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZAny: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZAny: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &Keyword{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Optional) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Optional: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Optional: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuestionMark == nil {
				m.QuestionMark = &Keyword{}
			}
			if err := m.QuestionMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interleave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interleave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interleave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCurly == nil {
				m.OpenCurly = &Keyword{}
			}
			if err := m.OpenCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiColon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SemiColon == nil {
				m.SemiColon = &Keyword{}
			}
			if err := m.SemiColon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraSemiColon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraSemiColon == nil {
				m.ExtraSemiColon = &Keyword{}
			}
			if err := m.ExtraSemiColon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseCurly == nil {
				m.CloseCurly = &Keyword{}
			}
			if err := m.CloseCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightArrow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightArrow == nil {
				m.RightArrow = &Keyword{}
			}
			if err := m.RightArrow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comma == nil {
				m.Comma = &Keyword{}
			}
			if err := m.Comma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Terminal == nil {
				m.Terminal = &Terminal{}
			}
			if err := m.Terminal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = &List{}
			}
			if err := m.List.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Function == nil {
				m.Function = &Function{}
			}
			if err := m.Function.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuiltIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuiltIn == nil {
				m.BuiltIn = &BuiltIn{}
			}
			if err := m.BuiltIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (types.Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCurly == nil {
				m.OpenCurly = &Keyword{}
			}
			if err := m.OpenCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, &Expr{})
			if err := m.Elems[len(m.Elems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseCurly == nil {
				m.CloseCurly = &Keyword{}
			}
			if err := m.CloseCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuiltIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuiltIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuiltIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Symbol == nil {
				m.Symbol = &Keyword{}
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Terminal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Terminal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Terminal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Literal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UintValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BoolValue = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append(m.BytesValue[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesValue == nil {
				m.BytesValue = []byte{}
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Variable == nil {
				m.Variable = &Variable{}
			}
			if err := m.Variable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (types.Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Space) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Space: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Space: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Space = append(m.Space, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &Name{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyName == nil {
				m.AnyName = &AnyName{}
			}
			if err := m.AnyName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyNameExcept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyNameExcept == nil {
				m.AnyNameExcept = &AnyNameExcept{}
			}
			if err := m.AnyNameExcept.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameChoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameChoice == nil {
				m.NameChoice = &NameChoice{}
			}
			if err := m.NameChoice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Name) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Name: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Name: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UintValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BoolValue = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append(m.BytesValue[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesValue == nil {
				m.BytesValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Underscore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Underscore == nil {
				m.Underscore = &Keyword{}
			}
			if err := m.Underscore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyNameExcept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyNameExcept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyNameExcept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclamation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exclamation == nil {
				m.Exclamation = &Keyword{}
			}
			if err := m.Exclamation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Except", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Except == nil {
				m.Except = &NameExpr{}
			}
			if err := m.Except.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &NameExpr{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipe == nil {
				m.Pipe = &Keyword{}
			}
			if err := m.Pipe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &NameExpr{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRelapse(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRelapse
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRelapse
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRelapse(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRelapse = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRelapse   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("relapse.proto", fileDescriptor_relapse_9e0d729cf4b37f53) }

var fileDescriptor_relapse_9e0d729cf4b37f53 = []byte{
	// 1448 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0xae, 0xd7, 0x71, 0xfc, 0x9c, 0xa4, 0x68, 0x84, 0xc4, 0x2a, 0x6a, 0x5d, 0x77, 0x4b,
	0xab, 0x50, 0x4a, 0x52, 0xa2, 0x4a, 0x20, 0x6e, 0xb6, 0x6b, 0x20, 0x22, 0x4d, 0xc2, 0xa4, 0xed,
	0xa1, 0xb7, 0x89, 0x3d, 0x49, 0x56, 0x5d, 0xef, 0x6e, 0x67, 0xc7, 0x34, 0xbe, 0xf2, 0x0f, 0xc0,
	0x5f, 0x80, 0x38, 0x73, 0x42, 0x42, 0x88, 0x1b, 0x42, 0x48, 0x48, 0x3d, 0x70, 0xe8, 0xb1, 0x27,
	0x04, 0xa9, 0xc4, 0x8d, 0x23, 0x77, 0x34, 0x3f, 0x76, 0x77, 0xd6, 0xdd, 0x38, 0x0e, 0x52, 0x25,
	0xb8, 0x38, 0xbb, 0xdf, 0xf7, 0xed, 0xcc, 0xbc, 0x6f, 0xde, 0xbc, 0x99, 0x09, 0x2c, 0x31, 0x1a,
	0x90, 0x38, 0xa1, 0x6b, 0x31, 0x8b, 0x78, 0x84, 0x2a, 0x24, 0xe1, 0x2b, 0xef, 0x1c, 0xfa, 0xfc,
	0x68, 0xb4, 0xbf, 0xd6, 0x8f, 0x86, 0xeb, 0x87, 0xd1, 0x61, 0xb4, 0x2e, 0xb9, 0xfd, 0xd1, 0x81,
	0x7c, 0x93, 0x2f, 0xf2, 0x49, 0x7d, 0xb3, 0x72, 0xdb, 0x90, 0x3f, 0x22, 0x7c, 0x3c, 0xf0, 0x07,
	0xd9, 0x5f, 0xdd, 0xfa, 0x3a, 0x1f, 0xc7, 0x34, 0x51, 0xbf, 0xea, 0x2b, 0xef, 0x0b, 0x0b, 0x6a,
	0x1f, 0x31, 0x32, 0x1c, 0x12, 0x86, 0x6e, 0x02, 0xdc, 0x8b, 0xe2, 0x5d, 0xc2, 0x39, 0x65, 0xa1,
	0x6b, 0xb5, 0xac, 0xd5, 0xc6, 0xc6, 0xe2, 0x1a, 0x49, 0xf8, 0x9a, 0xc6, 0xb0, 0xc1, 0xa3, 0xdb,
	0xb0, 0xa8, 0x1f, 0xef, 0xd0, 0x7e, 0x90, 0xb8, 0x76, 0xab, 0xb2, 0xda, 0xd8, 0x78, 0xcd, 0xd4,
	0x0b, 0x02, 0x17, 0x54, 0xa8, 0x05, 0xd5, 0xf6, 0x01, 0xa7, 0xcc, 0xad, 0xc8, 0xe6, 0x41, 0xca,
	0xf7, 0x62, 0xd2, 0xa7, 0x58, 0x11, 0xde, 0x77, 0x16, 0x34, 0x8c, 0x4f, 0x50, 0x0b, 0x9c, 0x8f,
	0x49, 0x72, 0x54, 0x18, 0xcf, 0x27, 0x74, 0xfc, 0x24, 0x62, 0x03, 0x2c, 0x19, 0xe4, 0xc1, 0x7c,
	0x87, 0x1e, 0x44, 0x8c, 0xba, 0xf6, 0x4b, 0x8d, 0x6a, 0x06, 0xb9, 0xe0, 0x6c, 0x93, 0x21, 0x95,
	0xdd, 0xd6, 0x3b, 0xce, 0xd3, 0xdf, 0x2e, 0xcf, 0x61, 0x89, 0xa0, 0x8b, 0x60, 0xf7, 0x1e, 0xbb,
	0x4e, 0x49, 0xeb, 0x76, 0xef, 0x31, 0xba, 0x0e, 0xb5, 0xd4, 0x90, 0x6a, 0x89, 0x21, 0x29, 0xe9,
	0x7d, 0xee, 0x64, 0x42, 0x11, 0x63, 0x6f, 0x18, 0xf3, 0xb1, 0x1e, 0xb2, 0x1a, 0x8e, 0x44, 0xb0,
	0x22, 0xd0, 0x5b, 0xb0, 0x70, 0x8f, 0x51, 0xba, 0x1d, 0x0d, 0xa8, 0x36, 0x62, 0x49, 0x8a, 0x52,
	0x10, 0x67, 0xb4, 0x90, 0x6e, 0x51, 0x72, 0x20, 0xa5, 0x8e, 0x21, 0x4d, 0x41, 0x9c, 0xd1, 0xe8,
	0x2a, 0xcc, 0x77, 0xa3, 0xb0, 0x4f, 0xb8, 0x1e, 0x6a, 0x43, 0x0a, 0x15, 0x84, 0x35, 0x85, 0xde,
	0x00, 0x7b, 0x87, 0xb9, 0xf3, 0x52, 0x50, 0x93, 0x82, 0x1d, 0x86, 0xed, 0x1d, 0x86, 0x56, 0xa0,
	0xd2, 0x0e, 0x07, 0x6e, 0x4d, 0x32, 0x0b, 0x92, 0x69, 0x87, 0x03, 0x2c, 0x40, 0xb4, 0x0e, 0xf0,
	0x90, 0xb2, 0x68, 0x87, 0xdd, 0x15, 0x2e, 0x2f, 0x48, 0xc9, 0x05, 0x29, 0xc9, 0x61, 0x6c, 0x48,
	0xd0, 0x4d, 0xa8, 0x63, 0x7a, 0x40, 0x19, 0x0d, 0xfb, 0xd4, 0xad, 0x4b, 0xfd, 0xb2, 0xd4, 0x67,
	0x28, 0xce, 0x05, 0xa2, 0xeb, 0xed, 0x88, 0xbb, 0x60, 0x74, 0xbd, 0x1d, 0x71, 0x2c, 0x40, 0x74,
	0x09, 0x9c, 0x87, 0xed, 0x70, 0xec, 0x36, 0x24, 0x59, 0x57, 0x9d, 0xb6, 0xc3, 0x31, 0x96, 0xb0,
	0xb0, 0xa7, 0x1b, 0x85, 0x9c, 0xf8, 0x61, 0xe2, 0x2e, 0x1a, 0xf6, 0xa4, 0x20, 0xce, 0x68, 0x21,
	0xdd, 0x89, 0xb9, 0x1f, 0x85, 0x24, 0x70, 0x97, 0x0c, 0x69, 0x0a, 0xe2, 0x8c, 0x16, 0xf1, 0x6e,
	0x86, 0x9c, 0xb2, 0x80, 0x92, 0xcf, 0xa8, 0xbb, 0x6c, 0xc4, 0x9b, 0xc3, 0xd8, 0x90, 0x7c, 0xe0,
	0x3c, 0xfd, 0xfa, 0xb2, 0xe5, 0xbd, 0xad, 0x27, 0x1e, 0x79, 0xc5, 0x0c, 0x28, 0xa6, 0x95, 0xa2,
	0xbc, 0x71, 0x9e, 0x03, 0xe8, 0x8a, 0xce, 0x4e, 0xcb, 0x18, 0x96, 0x00, 0x7a, 0xc7, 0x31, 0xd3,
	0x69, 0xea, 0x41, 0xb5, 0x1b, 0x05, 0x51, 0xa8, 0x73, 0x7c, 0xa2, 0x49, 0x49, 0x99, 0xc9, 0x5a,
	0x99, 0x96, 0xac, 0x38, 0x37, 0x0d, 0x35, 0xa1, 0x72, 0x27, 0xe2, 0xa5, 0x03, 0x15, 0x84, 0xd9,
	0xa6, 0x3d, 0xad, 0x4d, 0x23, 0x4f, 0xc5, 0x9c, 0x89, 0x91, 0xeb, 0x46, 0xd5, 0x9c, 0xa9, 0x50,
	0xc4, 0xaf, 0xf7, 0x95, 0x9d, 0x26, 0x2a, 0x5a, 0x83, 0xc6, 0x4e, 0x4c, 0xc3, 0x0e, 0x23, 0xfd,
	0x47, 0x94, 0x97, 0xc6, 0x66, 0x0a, 0x84, 0x7e, 0x8b, 0x1e, 0xf0, 0x69, 0x51, 0x9a, 0x02, 0xe5,
	0xda, 0x70, 0x48, 0x4a, 0xd7, 0xb7, 0xa2, 0xd0, 0x2d, 0x58, 0xc4, 0xfe, 0xe1, 0x11, 0x9f, 0xb6,
	0xce, 0x0b, 0x0a, 0x51, 0x28, 0x7b, 0xc7, 0x9c, 0x11, 0xd5, 0xf4, 0x7c, 0x49, 0xd3, 0x06, 0x2f,
	0xda, 0xef, 0x06, 0x51, 0x42, 0xd3, 0x20, 0x6b, 0x25, 0xfa, 0x82, 0xc2, 0x3b, 0xb1, 0xc4, 0x22,
	0x45, 0x37, 0xa0, 0x2e, 0x62, 0xdf, 0x25, 0x8c, 0x86, 0xa5, 0x13, 0x94, 0xd3, 0x93, 0xc6, 0xd8,
	0x67, 0x19, 0xd3, 0x02, 0x67, 0xd7, 0x8f, 0x69, 0xc1, 0xc1, 0xac, 0xaa, 0x0a, 0xe6, 0x25, 0x5b,
	0x9c, 0x59, 0x6c, 0x91, 0x61, 0xa8, 0x01, 0x57, 0xcb, 0x6c, 0xc9, 0x79, 0xef, 0x2f, 0x4b, 0x16,
	0x9c, 0x57, 0x1a, 0xe5, 0x0d, 0xa8, 0xb7, 0x87, 0x31, 0x65, 0x09, 0x09, 0x07, 0xa5, 0xa1, 0xe6,
	0xf4, 0x2b, 0x8f, 0xf7, 0x5b, 0xcb, 0x2c, 0xa2, 0xe7, 0x0a, 0x7b, 0xc6, 0x35, 0x38, 0x31, 0xa0,
	0xca, 0xf4, 0x01, 0x89, 0x14, 0xd8, 0xe3, 0x84, 0x95, 0x2e, 0x0d, 0xc9, 0x78, 0x5d, 0xa3, 0x8a,
	0x8b, 0x7d, 0xb2, 0x5d, 0x5e, 0x27, 0xec, 0x36, 0xcf, 0xf6, 0x57, 0x7b, 0x72, 0x7f, 0xf5, 0x7e,
	0xb0, 0x64, 0x75, 0x17, 0x73, 0xd7, 0x3b, 0xee, 0x07, 0x64, 0x48, 0x44, 0x91, 0x2d, 0x6d, 0xc8,
	0x14, 0x14, 0x0d, 0xb2, 0x67, 0x36, 0xa8, 0x32, 0xbb, 0x41, 0xce, 0x19, 0x33, 0xb6, 0xaa, 0xb6,
	0x9e, 0xcc, 0x28, 0xeb, 0x54, 0xa3, 0x7e, 0xb4, 0xf2, 0xbd, 0xe5, 0x3f, 0x30, 0xb3, 0xb7, 0x60,
	0xf1, 0xd3, 0x11, 0x4d, 0xc4, 0x78, 0xee, 0x12, 0xf6, 0xa8, 0x34, 0xd0, 0x82, 0xc2, 0xfb, 0xc6,
	0x36, 0x77, 0xbc, 0x34, 0x84, 0xee, 0x88, 0x05, 0xe3, 0xd3, 0xbd, 0x97, 0xf4, 0xb9, 0x4b, 0xf2,
	0x0d, 0xa8, 0xef, 0xd1, 0xa1, 0xaf, 0x36, 0xb3, 0xb2, 0x91, 0xe5, 0xf4, 0xbf, 0x28, 0xcd, 0xb7,
	0x61, 0x59, 0x96, 0xde, 0xbc, 0x8b, 0xb2, 0xf2, 0x3c, 0xa1, 0xc9, 0xec, 0x55, 0x01, 0xd7, 0x4e,
	0xb5, 0x57, 0xf2, 0xde, 0xdf, 0x96, 0xda, 0xdf, 0xc4, 0x67, 0xb2, 0xf3, 0x36, 0x63, 0xd1, 0x93,
	0xd2, 0xa9, 0x36, 0xf8, 0x7c, 0x2f, 0xb2, 0x4f, 0xdf, 0x8b, 0xc4, 0xc1, 0x90, 0xb2, 0xa1, 0x2f,
	0xce, 0x28, 0x85, 0x83, 0xa1, 0x06, 0x71, 0x46, 0x8b, 0x4d, 0x76, 0xcb, 0x4f, 0xb8, 0xb6, 0x50,
	0x6d, 0xb2, 0x02, 0xc0, 0x12, 0x16, 0x2d, 0x7d, 0x38, 0x0a, 0xfb, 0x72, 0xad, 0x55, 0x8d, 0x96,
	0x52, 0x10, 0x67, 0xb4, 0x48, 0xc2, 0xce, 0xc8, 0x0f, 0xf8, 0x66, 0xd1, 0x2c, 0x8d, 0xe1, 0x94,
	0xf4, 0x7e, 0xb5, 0x54, 0x97, 0xc6, 0x81, 0xdb, 0x3a, 0xf5, 0xc0, 0x7d, 0x0d, 0x9c, 0x7b, 0xe3,
	0x58, 0x15, 0x84, 0xe5, 0x8d, 0xc6, 0x9a, 0xba, 0x74, 0x08, 0x28, 0xad, 0x0e, 0xe2, 0xb9, 0x98,
	0x69, 0x95, 0xe9, 0x99, 0x76, 0x19, 0xaa, 0xbd, 0x80, 0x0e, 0x13, 0xd7, 0x91, 0x57, 0x0d, 0xe3,
	0x5c, 0xa1, 0xf0, 0x89, 0x69, 0xac, 0x9e, 0x31, 0x8d, 0xbf, 0x58, 0xb9, 0x45, 0x33, 0x85, 0x74,
	0x6a, 0x8d, 0x2b, 0x2e, 0xf9, 0xca, 0xf4, 0x25, 0x7f, 0x05, 0xe6, 0x77, 0x09, 0x23, 0x65, 0x61,
	0x68, 0xe2, 0x9c, 0x1b, 0xcb, 0x76, 0x36, 0x7d, 0xe8, 0x4d, 0x98, 0xdf, 0x1b, 0x0f, 0xf7, 0xa3,
	0xa0, 0x34, 0x19, 0x35, 0x97, 0x1d, 0xcf, 0xec, 0xf2, 0xe3, 0xd9, 0xf7, 0x76, 0x9e, 0x84, 0x33,
	0xf9, 0xd2, 0x84, 0xda, 0x96, 0xcf, 0x29, 0x23, 0x41, 0xc1, 0x9a, 0x14, 0x44, 0x2d, 0x68, 0xdc,
	0x89, 0x46, 0xfb, 0x01, 0x7d, 0x40, 0x82, 0x91, 0x3a, 0x72, 0x58, 0xd8, 0x84, 0xd0, 0x0a, 0x2c,
	0x6c, 0x86, 0x5c, 0xd1, 0x22, 0xdc, 0x0a, 0xce, 0xde, 0xd1, 0x45, 0xa8, 0xdf, 0xf7, 0x53, 0x52,
	0xe4, 0xa7, 0x83, 0x73, 0x40, 0xb0, 0x9d, 0x28, 0x0a, 0x14, 0x2b, 0x2e, 0x26, 0x0b, 0x38, 0x07,
	0x44, 0xcf, 0x7b, 0x9c, 0xf9, 0xe1, 0xa1, 0xe2, 0xc5, 0x45, 0xa4, 0x8e, 0x4d, 0x08, 0x35, 0x01,
	0x3a, 0x63, 0x4e, 0x13, 0x25, 0x10, 0x37, 0x90, 0x45, 0x6c, 0x20, 0x62, 0x19, 0x3d, 0x20, 0xcc,
	0x27, 0xfb, 0x01, 0x75, 0x37, 0x8c, 0x65, 0x94, 0x82, 0x38, 0xa3, 0xbd, 0x77, 0x73, 0xe9, 0x8c,
	0xd9, 0xef, 0x6d, 0x42, 0x4d, 0x4f, 0xce, 0x4c, 0x46, 0xaf, 0x40, 0x55, 0x8d, 0xd3, 0xb4, 0x59,
	0x41, 0xde, 0x25, 0xa8, 0x4a, 0x31, 0x7a, 0x5d, 0x3f, 0xb8, 0x56, 0xab, 0xb2, 0x5a, 0xc7, 0xea,
	0xc5, 0xfb, 0xd9, 0x82, 0x85, 0xf4, 0x46, 0x21, 0x12, 0xc0, 0xb8, 0x6e, 0xd4, 0xb3, 0xeb, 0x86,
	0xce, 0xe6, 0xeb, 0x50, 0x6b, 0x87, 0xe3, 0x2c, 0xd5, 0xd3, 0x34, 0xd2, 0x18, 0x4e, 0x49, 0xf4,
	0x3e, 0x2c, 0xe9, 0xc7, 0xde, 0x71, 0x9f, 0xc6, 0x5c, 0x67, 0x3e, 0x32, 0xd5, 0x8a, 0xc1, 0x45,
	0xa1, 0xb8, 0x5f, 0x89, 0xb7, 0xee, 0x51, 0xe4, 0xf7, 0xd3, 0x6b, 0xed, 0x85, 0x6c, 0x18, 0x0a,
	0xc6, 0x86, 0x44, 0xdf, 0xaf, 0xfe, 0xb4, 0x20, 0xbd, 0x0c, 0x9d, 0x6d, 0xd6, 0xff, 0x38, 0xeb,
	0xbc, 0xf7, 0xb2, 0x19, 0x10, 0xb5, 0xe0, 0x7e, 0x38, 0xa0, 0x2c, 0xe9, 0xe7, 0xe1, 0x4e, 0xd4,
	0x82, 0x9c, 0xf7, 0x7e, 0xb2, 0x26, 0xe6, 0xe4, 0x95, 0x1e, 0xbb, 0xae, 0xc1, 0x7c, 0x61, 0xe6,
	0x27, 0x2e, 0xae, 0x9a, 0x3c, 0xe7, 0xa9, 0xeb, 0x99, 0x65, 0x26, 0xc7, 0xb9, 0x4e, 0x53, 0x57,
	0xc0, 0x11, 0x27, 0x0d, 0x3d, 0xec, 0xc9, 0x6b, 0xb4, 0xa0, 0x66, 0xb8, 0xf7, 0x5c, 0x85, 0xaa,
	0xdc, 0xb4, 0x0b, 0xff, 0x6d, 0xc9, 0x5a, 0x51, 0xdc, 0xf9, 0x2a, 0x74, 0xe7, 0xe2, 0xf3, 0x3f,
	0x9a, 0x73, 0x4f, 0x4f, 0x9a, 0xd6, 0xb3, 0x93, 0xa6, 0xf5, 0xfb, 0x49, 0xd3, 0xfa, 0xf2, 0x45,
	0x73, 0xee, 0xd9, 0x8b, 0xe6, 0xdc, 0xf3, 0x17, 0xcd, 0xb9, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x08, 0x5d, 0xf7, 0x16, 0xfc, 0x13, 0x00, 0x00,
}
